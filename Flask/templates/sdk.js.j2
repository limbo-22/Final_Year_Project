// sdk.js.j2  ‚Äî rendered as /sdk.js by Flask

// 1) ‚ÄúAPI_URL‚Äù can be "" (relative paths) or "https://‚Ä¶/flask"
//    You inject it from Flask‚Äôs render_template call.
const API = "{{ API_URL }}";
const SHOP_OWNER = "{{ SHOP_OWNER_ADDRESS }}".toLowerCase();

// üëë SDK wrapper for your game UI
const SDK = {
  provider: null,
  signer:   null,
  user:     null,
  contracts:null,
  erc721_abi:      null,
  erc20_abi:       null,
  onAccountChange: null,  // optional callback

  // 1) Load both ABIs, once on startup
  async loadConfig() {
    if (!this.contracts) {
      const { contracts, erc721_abi, erc20_abi } =
        await fetch(`${API}/contracts`).then(r=>r.json());
      this.contracts   = contracts;
      this.erc721Abi   = erc721_abi;
      this.erc20Abi    = erc20_abi;
    }
  },

  // helper to give you an ethers.Contract
  contractInstance(name) {
    if (!this.signer) throw new Error("Not connected");
    const addr = this.contracts[name];
    // if it‚Äôs ‚Äúgold‚Äù use the ERC20 ABI, otherwise ERC721
    const abi  = name === 'gold' ? this.erc20Abi : this.erc721Abi;
    return new ethers.Contract(addr, abi, this.signer);
  },

  // connect MetaMask and return the lowercase address
  async connect() {
    if (!window.ethereum) throw new Error("MetaMask not found");
    this.provider = new ethers.BrowserProvider(window.ethereum);
    await window.ethereum.request({ method: "eth_requestAccounts" });
    this.signer = await this.provider.getSigner();
    this.user   = (await this.signer.getAddress()).toLowerCase();

    await this.loadConfig();
    await this.refreshButtons();
    if (this.onAccountChange) this.onAccountChange(this.user);
    return this.user;
  },

  async init() {
    if (!window.ethereum) return;
    this.provider = new ethers.BrowserProvider(window.ethereum);
    await this.loadConfig();

    // 1Ô∏è‚É£ Silent reconnect if already authorized (no popup)
    const accounts = await this.provider.listAccounts();
    if (accounts.length) {
      // first entry might be { address: "0x‚Ä¶" } or a plain string
      const raw = accounts[0];
      const addr = typeof raw === "string" ? raw : raw.address;
      this.signer = await this.provider.getSigner();
      this.user   = addr.toLowerCase();
      await this.refreshButtons();
      if (this.onAccountChange) this.onAccountChange(this.user);
    }

    // 2Ô∏è‚É£ Listen for account changes
    window.ethereum.on("accountsChanged", async (accounts) => {
    if (accounts.length) {
      // this event *should* give you strings, but guard anyway
      const raw = accounts[0];
      const addr = typeof raw === "string" ? raw : raw.address;
      this.signer = await this.provider.getSigner();
      this.user   = addr.toLowerCase();
      } else {
        this.signer = null;
        this.user   = null;
      }
      await this.refreshButtons();
      if (this.onAccountChange) this.onAccountChange(this.user);
    });

  },

  // mint via backend + safeMint on-chain
  async mint(itemType) {
    if (!this.user) throw new Error("Not connected");
    // 1Ô∏è‚É£ backend mint
    let res = await fetch(`${API}/mint/${itemType}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ user: this.user })
    });
    if (!res.ok) {
      const err = await res.json().catch(async () => ({ error: await res.text() }));
      throw new Error(err.error || "Mint failed");
    }
    const { metadata_uri } = await res.json();

    // 2Ô∏è‚É£ on-chain safeMint
    const cinfo = await fetch(`${API}/contracts`).then(r=>r.json());
    const contract = new ethers.Contract(
      cinfo.contracts[itemType], this.erc721Abi, this.signer
    );
    const tx = await contract.safeMint(this.user, metadata_uri);
    await tx.wait();
    return metadata_uri;
  },

  // fetch & render button states
  async refreshButtons() {
    document.querySelectorAll("button[data-item]").forEach(btn => {
      btn.disabled  = false;
      btn.innerText = btn.dataset.defaultText;
    });
    if (!this.user) return;
    const inv = await fetch(`${API}/inventory/${this.user}`).then(r=>r.json());
    inv.forEach(i => {
      const btn = document.querySelector(`button[data-item="${i.item}"]`);
      if (btn) {
        btn.disabled  = true;
        btn.innerText = `‚úÖ ${i.item}`;
      }
    });
  },

  // populate your inventory modal
  async showInventory() {
    if (!this.user) throw new Error("Not connected");
    const inv = await fetch(`${API}/inventory/${this.user}`).then(r=>r.json());
    const list = document.getElementById("inventory-list");
    list.innerHTML = inv.map(i => `
      <div class="card">
        <img src="${i.image_url}" alt="${i.name}" />
        <h4>${i.name}</h4>
        <p>${i.description}</p>
        <a href="${i.metadata_url}" target="_blank">View Metadata</a>
      </div>
    `).join("");
    document.getElementById("inventory-modal").style.display = "block";
  },

  hideInventory() {
    document.getElementById("inventory-modal").style.display = "none";
  },


  fetchBalance: async function(token, user_address) {
    if (!user_address) throw new Error("Not connected");
    // hit the new /balance/<token>/<user_address> route
    const res = await fetch(`/balance/${token}/${user_address}`);
    if (!res.ok) throw new Error("Failed to fetch balance");
    return res.json();   // { raw:‚Ä¶, human:‚Ä¶ }
  },

  /**
   * 4.5 Purchase an item with ERC-20 gold, then mint the NFT.
   */
  async purchase(itemType, price) {
    if (!this.user) throw new Error("Not connected");

    await this.loadConfig();

    // 1) make a token‚Äêcontract instance
    const token = new ethers.Contract(
      this.contracts.gold,
      this.erc20Abi,
      this.signer
    );

    // 2) calculate raw units from human price
    const dec       = await token.decimals();
    const rawPrice  = ethers.parseUnits(price.toString(), dec);

    // 3) check balance
    const bal = await token.balanceOf(this.user);
    if (bal < rawPrice) {
      throw new Error(`You need ${price} gold to buy a ${itemType}`);
    }

    // 4) transfer directly to shop owner
    const tx = await token.transfer(SHOP_OWNER, rawPrice);
    await tx.wait();

    // 5) now mint the NFT via your existing backend
    return this.mint(itemType);
  },

  async mintToken(token, to, amount) {
    if (!this.user) throw new Error("Not connected");
    await this.loadConfig();
    const c = new ethers.Contract(
      this.contracts[token],
      this.erc20Abi,
      this.signer
    );
    const tx = await c.mint(to, amount);
    await tx.wait();
    return tx;
  },

  async burnToken(token, from, amount) {
    if (!this.user) throw new Error("Not connected");
    await this.loadConfig();
    const c = new ethers.Contract(
      this.contracts[token],
      this.erc20Abi,
      this.signer
    );
    const tx = await c.burn(from, amount);
    await tx.wait();
    return tx;
  },

  async getTokenDecimals(token) {
    await this.loadConfig();
    const c = new ethers.Contract(
      this.contracts[token],
      this.erc20Abi,
      this.provider
    );
    return await c.decimals();
  }

  
};

window.SDK = SDK;
